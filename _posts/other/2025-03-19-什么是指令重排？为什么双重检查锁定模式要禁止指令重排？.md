---
layout: post
title:  "什么是指令重排？为什么双重检查模式锁定模式要禁止指令重排？"
date:   2025-03-19 23:00:00 +0800
categories: other
---
### 什么是指令重排？
简单来说，指令重排就是一种优化手段。其并不是某一个语言体系专属的优化手段，而是从语言编译器、操作系统最终到处理层面都具备的一种优化手段。其最终目的是减少cpu的等待时间，提高系统运行效率。

在是否进行指令重排时有一个特别重要的准则，即被重排的指令是否存在数据依赖性。以下面的代码为例：
```
int a = 1;
int b = 2;
int c = a + b;
```
在这段代码中，a=1和b=2这两条指令完全没有依赖性。所以在实际执行过程中先执行谁是不一定的，反正最终的计算结果不会受影响。

下列代码则不能指令重排
```
int a = 1;
int b = a;
int c = a + b;
```
在这段代码中，a和b之间存在数据依赖性。即初始化b之前必须初始化a才可以。所以这是不能做指令重排的。

### 为什么双重检查锁定模式的单例要禁止指令重排？
经典双重检查锁定模式代码如下所示：
```
public class Singleton {
    private static volatile Singleton instance;

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
这里有问题的代码是下面这句：
```
instance = new Singleton();
```
这一行看似是一条指令，实际是包括了一下四个指令：
1. 加载类文件
2. 分配内存空间
3. 初始化对象
4. 将对象引用指向分配的内存空间。


在这些指令中1和2是存在依赖性的，因此是无法被重排的。但3和4就不一样了，先执行谁在单线程条件下是不会有什么影响的，反正最后结果都一样。

但是在多线程环境下就大不相同。比如执行顺序变为1243，在多线程环境下当一个线程在执行完4号指令后被调度走不在继续执行时，其他线程在执行外层的空判断时将得到非空的结果。此时执行return后将拿到一个未被初始化的对象，如果是简单对象可能凑巧不会发生问题，但如果是一个必须经过初始化赋值的复杂对象恐怕就不会有那么幸运了。

所以在实现多线程环境下实现双重检查锁定模式时，一定要加相应的防指令重排措施。